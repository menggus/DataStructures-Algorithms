### 递归

### 通过斐波拉契数列来理解递归

-   斐波拉契数列：`1 1 2 3 5 8 13 21 ...`

    从数列可看出，菲薄拉切数列的某个值 = 等于该值前两个数之和

    `f(n) = f(n-1)+f(n-2) f(1)=1 f(2)=1`

    在求解斐波拉契数列的第n个值时，我们总是在计算第n-1和第n-2的值，而第n个值等于第n-1加上第n-2的值，即

    ​		父问题：求第n个数列的值 f(n)

    ​		子问题：求第n-1和第n-2的值，f(n-1)  f(n-2)

    ​		父子问题的关系：f(n)=f(n-1) + f(n-2)

    这样把求解一个问题的解，分解成求解该问题所有子问题的解，并通过父子问题的关系来实现求解父问题的过程。这种过程就是  递归的过程。递为递推，父问题推出子问题，子问题推出子子问题。归为回归，子子问题归解到子问题，子问题归解到父问题。

### 台阶问题

-   有n个台阶，每次允许跨1个台阶或者2个台阶，请问有多少种走法？

    父问题： n个台阶，求解走法 f(n)

    子问题：n-1个台阶走法   n-2台阶走法

    父子问题关系：n个台阶的走法等于先走1个台阶n-1个台阶的走法 加上 先走2个台阶n-2个台阶的走法

    ​		`f(n) =f(n-1) + f(n-2) `

    通过上述理解，同样也是一个递归的问题

### 递归需要满足的条件

-   一个问题的解可以分解为几个子问题的解
-   这个问题与分解之后的子问题，除了数据规模不一样，求解思路完全一样
-   存在递归的终止条件
    -   如数据规模n，斐波拉契数列第1个位置为1，第2个位置也为1
    -   台阶问题，如果只有1个台阶，那么就只有一种走法（走1个台阶），如果有2个台阶，那就有2中走法（分1次走2个台阶，分2次，1次走1个台阶）

### 递归过程注意事项：

我们在研究递归问题时，总喜欢一层一层去迭代，先计算一个值，然后返回，再计算一下返回，这样总会陷入思维的误区，而搞的头晕乎乎的。其实研究递归只需要搞懂几个方面也就是上面说的三个条件；

-   父问题的分解：理清父子问题关
-   递归终止条件

如果一个问题A可以分解为子问题B、C、D，你可以假设B、C、D问题已解决，在此基础上思考A问题，弄清楚A与B、C、D子问题的关系即可，屏蔽掉细节，最后弄清楚终止条件。

### 例子代码实现

```python
# 斐波拉契数列
def fib(n):
    if n==1 or n==2:
        return 1
    return fib(n-1)+fib(n-2)

# 台阶问题
def f(n):
    if n==1:
        return 1
    if n==2:
        return 2
    return f(n-1)+f(n-2)
```

### 递归需要注意的问题

-   堆栈溢出

    递归过程也就是重复调用函数的过程，而函数的调用会使用栈来保存临时变量，没调用一个函数，都会讲临时变量封装为栈帧压入栈，等函数执行完成后返回，才出栈。系统栈和虚拟机栈空间一般都不打，当递归的层次很深时，不断消耗栈空间，就会有堆栈溢出的风险。

    解决办法：记录递归深度depth，当深度达到一定次数，直接返回；只适用于较低层次递归（允许的最大递归深度跟当前线程剩余的栈空间有关，事先无法计算，如果实时计算会很复杂）；

    ```python
    # 斐波拉契数列
    depth = 0
    def fib(n):
        depth += 1
        if depth >50:
            # 抛出异常等操作
            return "throw exception"
        if n==1 or n==2:
            return 1
        return fib(n-1)+fib(n-2)
    ```

-   重复计算

    ![](http://im.taolius.com/image/recursive-repeat-compute.png)

    看上图中，f(6) , f(5), f(4)等都是有重复计算，当计算f(5)时，优惠重复计算f(4)，怎样解决重复计算提高效率呢？

    那就是通过一个 哈希表：key=n value=f(n) ，每次计算前都去哈希表查下是否存在第n个的值，有则直接获取，没有才计算（计算后再添加f(n)到哈希表）

### 查找最终推荐人问题

-   会员推荐在数据库中存储方式一般为下图中的方式

    ![](http://im.taolius.com/image/recursive-recommend.png)

    C的推荐人为B，B的推荐人为A

    可以使用递归查找，每次查找会员都是同样的sql操作，只是改变查找条件；

    但是直接采用递归查找会存在一些问题

    -   堆栈溢出：如果推荐链很长，就有可能发生。可以通过控制递归深度来进行处理
    -   推荐环：如果数据库存在脏数据，单只推荐的递归终止条件不存在，如C由B推荐，B由A推荐，A由C推荐，这样递归时就会出现死循环。可以通过维护一个哈希表来实现环的检测，每次获取到上层推荐人就去哈希表检测，是否存在，如果不存在就添加到哈希表，如果存在就表示有

