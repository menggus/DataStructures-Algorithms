### 线性表与非线性表

-   线性表
    -   形状结构就像线条一样，从前到后。
    -   除了数组外还有 **队列**、**栈**、**链表**

    ![](http://im.taolius.com/image/linear-table.png) 

-   非线性表

    -   与线性表对立，如**二叉树**、**堆**、**图**
    
    ![](http://im.taolius.com/image/linear-table-non.png)

### 数组(Array)

-   数据是一种线性表数据结构。它用一组连续的内存空间来存储一组具有相同类型的数据。

-   数组的特性
    -   连续内存空间

        数组的存储会申请一段连续的内存空间，如果申请空间不足以存储数据时，会申请更大的内存空间，然后拷贝之前数据到新申请的空间（这是非常耗时的操作）

    -   相同类型数据

        数组存储每一和元素均是同类型的

    -   数组元素地址计算

        `a[i]_address =base_address + i*data_type_size `

        base_address：数组的在内存中首地址

        data_type_size：数组中每个元素的大小

    -   数组对元素操作效率

        -   数组在**随机访问** 是非常高效的，通过地址计算直接定位到元素
        -   数组在**插入**、**删除**时，为了保证空间连续性，而需要数据搬移，从而降低效率，时间复杂度O(n)

-   针对数组插入和删除操作的优化
    -   如果对于数组元素并无顺序要求，当插入一个元素时，先记录插入位置元素，替换插入位置元素后，把记录的元素插入到数组的尾部；这样的插入操作相比需要元素搬移的插入操作效率大大提高
    -   对于删除操作，可先记录删除操作的元素，实际上并不立即删除，之后当数组存储空间不足时，再一次性删除已记录的删除的元素。这样也能提高数组关于删除操作的效率

-   数组越界问题
    -   数组的访问其实本质上是访问内存中的地址，通过地址偏移计算来访问目标地址中存放的元素。计算机内存地址是连续的，当我们访问超过了当前数组申请的地址时，对于c语言来说并不会报错，同样会访问到数组之外的地址，这样就出现了数组越界，产生不可预期的问题。但是对于其他语言例如Java，Python等，关于数组越界的问题，语言本身就会进行检查，并抛出异常等
    -   带来的问题：
        -   不可预期的错误
        -   关于黑客利用数组越界，访问到非法内存地址来攻击系统等

### 链表

-   一种线性表数据结构，通过把零散的内存串联起来，构成链表这种数据结构

-   链表特性

    -   相对于数组连续内存空间，在内存中形态为 **分散的**；

        在对于数组与链表内存空间的申请上，数组对内存的要求较高（连续内存空间），而链表较低（分散）

        举个例子：（不考虑其他因素）

        假设内存只剩10M了，而如果要申请10M大小的数组，极大可能失败，因为不可能刚好10M内存为连续的；但如果申请的是链表则可以。

    -    基础链表的结构-单链表

        ![](http://im.taolius.com/image/linked-list.png)

        -   节点：data + next 组成；data：数据部分；next：指向下一个节点的指针
        -   头节点：记录链表的基础地址
        -   尾节点：next 指向为 NULL 表示最后一个节点

    -   单链表基本操作

        -   随机访问

            由于链表的地址计算是通过上一个节点记录的，所以要访问一个节点，就需要遍历该节点之前的所有节点；随机访问时间复杂度为 O(n)

        -   插入

            ![](http://im.taolius.com/image/linked-list-insert.png)

            插入一个节点，只需要指针进行变换即可；时间复杂度为 O(1)

        -   删除

            ![](http://im.taolius.com/image/linked-list-delete.png)

            删除一个节点，同样也只需要指针进行变换即可；时间复杂度为 O(1)

    -   循环链表

        -   基本结构

            ![](http://im.taolius.com/image/linked-list-single-circular.png)

            相对于单链表来看，尾节点并不是指向NULL，而是指向头节点；

            类似于 **环状结构** 的数据比较适合使用循环链表；

    -   双向链表

        -   基本结构

            ![](http://im.taolius.com/image/linked-list-doubly.png)

            对比单链表，每一个节点还保存了前置节点的地址；这样双向链表就比单链表所在空间大；

        -   优势

            相比单链表，它能以O(1)时间复杂度查找到前置节点；在之前的我们说，链表的删除操作是O(1)复杂度；

            这是在没考虑查找到要删除节点的时间复杂度；

            -   删除给定指定值的节点

                对于该情况，均需要遍历链表查找到值等于给定值的节点，并删除；时间复杂度为O(n)

            -   删除给定指针指向的节点

                当给定指针指向节点，对于单链表，还是需要通过遍历获取到前置节点O(n)，再进行删除操作；而对于双向链表，直接获取到前置节点O(1)，在进行删除操作；

    -   双向循环链表

        -   基本结构

            ![](http://im.taolius.com/image/linked-list-doubly-circular.png)

### 数组 VS 链表

| 时间复杂度 | 数组 | 链表 |
| :--------: | ---- | ---- |
| 插入、删除 | O(n) | O(1) |
|  随机访问  | O(1) | O(n) |

-   数组申请需要连续的内存空间，当申请较大的空间时，如果内存中不够连续内存，则会申请失败，链表则不然；数组比较符合内存使用苛刻的情况；
-   数组的随机访问是非常的高效，而且得益于CPU的缓存机制，预先读取数组中的数据，所以访问效率更高；
-   数组的插入，删除以及扩容均涉及数组中数据的搬移，所以非常耗时，而链表就比较高效，直接变换节点指针或者申请一个内存存放节点即可；但是链表频繁的插入和删除操作会是的内存空间碎片化，对于本身带有垃圾回收的语言，会导致频繁垃圾回收
-   链表在内存占用上由于需要存储指针会比数组大，所以对于较小内存的设备，由于内存大小限制，更适合数组；这样体现了   以时间换空间的思想；

### 使用链表实现LRU缓存淘汰算法

-   思路

    使用一个有序链表，越靠近链表尾部的节点是越早前使用的，当有一个新的数据使用时，我们就顺序遍历缓存链表。

    1、如果数据在缓存链表中，我们就把该数据所在节点删除，并把该数据插入到缓存链表头部；

    2、如果数据不在链表中，又分为两种情况：

    ​	a、如果此时缓存未满，则把该节点插入到链表头部；

    ​	b、如果此时缓存已满，则删除尾部节点，再把该节点插入到链表头部；

    上述就为LRU缓存淘汰算法的简单实现思路。

    该算法的时间复杂度：O(n)   (主要耗时在遍历链表，检测数据是否存在)

-   优化思路

    在遍历检测数据时，采用散列表进行查询，采用散列表key存储链表值，value存储链表指针；这样在检测时，可直接检测链表中是否存在数据，通过指针进行数据的插入和删除操作。