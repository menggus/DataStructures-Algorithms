### 栈&队列

### 栈

-   是一种操作受限的线性表数据结构，只允许入栈和出栈操作，入栈和出栈策略 **后进先出**；

-   栈结构及其特点

    ![](http://im.taolius.com/image/stack.png)

    -   只允许一端添加和删除数据的操作
    -   操作逻辑符合  **后进先出** 和 **先进后出** 
    -   入栈和出栈操作的时间复杂度：O(1)    空间复杂度：O(1)

### 顺序栈 & 链式栈

-   基于数组实现的栈，称为顺序栈；基于链表实现的栈，称为链式栈
-   由于不管是顺序栈还是链式栈，均只是对于数组和链表在一端进行数据添加和删除，所以时间复杂度均为O(1)
-   链式栈由于链表需要存储指针的原因，所以在资源消耗上比顺序栈要多
-   链式栈基于链表天然支持扩容

### 支持扩容的顺序栈

-   由于顺序栈是基于数组的，对顺序栈扩容本质上就是对数组进行扩容。当栈满之后，重新申请一个大的数组，然后把数据进行搬移，这样就实现了顺序栈的扩容；

### 栈的应用

-   表达式求值

    ![](http://im.taolius.com/image/stack-Arithmetic.png)

    -   碰到数字则压入左边栈（数据栈），碰到符号压入右边栈（符号栈）

    -   符号入栈规则

        符号入栈时，会与栈顶符号进行比较，如果优先级高则压入栈顶；如果优先级比栈顶符号低，则从数据栈栈顶取（出栈）两条数据，从符号栈栈顶取（出栈）符号进行计算，计算结果压入数据栈顶；继续与符号栈顶的符号比较优先级；

-   括号匹配

    ![](http://im.taolius.com/image/stack-brackets.png)

    -   每次括号入栈均与栈顶符号进行匹配，是否组合成为一个完整的括号，组合成功则栈顶括号出栈，否则括号压入栈顶

-   浏览器 前进&后退

    ![](http://im.taolius.com/image/stack-browser.png)

    ​	

    -   左边为X栈，栈顶为当前页面；右边为后Y栈；
    -   当新打开一个页面，则压入X栈顶，继续打开新页面则继续压入X栈；
    -   当点击浏览器后退按钮，则从X栈取出栈顶页面放入Y栈；
    -   当点击浏览器前进按钮，则从Y栈取出栈顶页面放入X栈；
    -   当Y栈有页面时，跳转新页面，则需要清空Y栈，如第8步；

-   函数调用

    ![](http://im.taolius.com/image/stack-function.png)

    -   通过简化过程来描述函数调用

    -   一个函数会有自己的栈帧，当调用其他函数时会被调用函数会申请一个栈帧来存储函数变量，函数执行完成，通过返回结果，而存放到调用者的栈帧中。

    -   函数调用过程与栈的后进先出的特性比较符合

        函数a调用函数b而函数b中又调用函数c，在计算过程中是不是最后调用的函数c先执行，然后返回到b函数中，b函数中执行，同理会返回到a函数，然后计算a函数返回结果。c→b→a函数执行顺序，也就是符合栈的后进先出策略。

### 队列

-   与栈一样也是一种操作受限的线性表，队列有入队和出队的操作，操作策略 先进先出

-   结构及其特点

    ![](http://im.taolius.com/image/queue-get-elem.png)

    -   队列有队头和队尾，HEAD指向对头，TAIL指向队尾
    -   对头有出队操作 dequeue， 队尾入队操作 enqueue
    -   队列的策略为：先进先出

### 顺序队列 & 链式队列

-   与栈类似，队列基于数组实现为顺序队列，基于链表实现为链式队列

-   顺序队列

    -   基于数组实现，入队操作等价于数组在尾部添加元素；而出队操作，数组为保持连续性，会进行数据搬迁，所以出队操作同样会对数据进行搬迁，这样的时间复杂度O(n)
    -   优化：每次出队操作并不会进行队列中数据的搬移操作，只移动队列的头部HEAD，而是当队列没有空闲空间时，在入队操作，进行一次集中数据的搬移工作；

    ![](http://im.taolius.com/image/queue-move-elem.png)

-   链式队列

    -   基于链表实现

        ![](http://im.taolius.com/image/queue-use-linked.png)

### 循环队列

-   在基于数组实现的队列中，在队列无空闲空间时会进行数据搬移操作，有没有解决办法呢？循环队列出场

-   结构：

    ![](http://im.taolius.com/image/queue-circular.png)

    -   循环队列的形状结构类似于环型；
    
    -   入队操作
    
        先通过HEAD和TAIL来进行判断，是否队列还有剩余空间，如果有则TAIL指向地址进行加1，并存入入队的元素；
    
    -   出队操作
    
        先判断队列中是否存在元素，如果存在则取出HEAD指向的元素，HEAD并进行指向地址进行加1；
    
-   循环队列边界条件的处理

    -   第一种方式，如果TAIL指向为最后一个元素+1的位置，即TAIL指向为空

        ![](http://im.taolius.com/image/queue-circular-2.png)

        -   空队列

            HEAD与TAIL指向同一地址位，HEAD = TAIL时，队列为空

        -   满队列，如右图

            判断条件：(TAIL+1)%8 = HEAD 时，队列为满队列

    -   第二方式，通过变量记录队列元素的个数
      
        -   通过元素个数与队列长度进行 比较来判断队列的是否为空，是否已满

### 队列应用之阻塞队列 & 并发队列

-   阻塞队列

    -   阻塞队列特点

        -   阻塞队列其实就是在队列的基础上加上阻塞操作
        -   队列为空时，从队头取数据会被阻塞，知道队列中有数据时，才会返回数据
        -   队列满时，入队操作会被阻塞，直接队列有多余空间，才会执行入队操作

    -   基于阻塞队列实现：生产者 消费者模型

        ![](http://im.taolius.com/image/queue-create-customer.png)

        -   消费者通过出队操作取数据，当队列为空时，则出队操作被阻塞，等待数据
        -   生产者通过入队操作添加数据，当队列满时，则入队操作被阻塞，等待空闲队列空间

    -   阻塞队列的好处

        -   协调消费者生成者速度：当消费者速度快，队列一下空了， 则会被阻塞等待生产者向队列添加数据，同理生产者速度过快，当队列满时，也会被阻塞，等待消费者处理队列中数据

-   并发队列

    -   消费者生产者模型，如果生成者速度很快，为了提高数据处理效率，通过增加消费者的数量来提高数据处理效率；当多个消费者同时从队列中拿数据，存在很大的安全隐患。如果实现了安全的多消费者取数据的过程，我们程该队列为 并发队列

    -   特点：

        -   多消费者，多生产者
        -   数据处理效率极大提高
        -   会存在安全隐患，但通过锁等安全机制，来实现多任务的数据安全；但锁的上锁解锁过程，又带来负面的影响，同一时刻仅允许一个取数据的线程来执行，这样会降低并发度；

    -   并发队列线程安全另一实现机制   

        除了使用锁机制来实现并发队列的线程安全，还可以 基于循环队列，利用CAS原子操作来实现高并发队列