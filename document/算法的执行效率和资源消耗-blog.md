### 怎么去分析和评估算法？

-   关键词：执行效率 与 资源占用

    我们在实际工作中常常是以计算机跑一遍代码来看它的执行效率，这样来看代码的执行效率是没错的。但我们在研究算法的执行效率时，还需要在计算机一遍一遍测试吗？答案是否定的。在分析和评估算法时，弄清楚我们的参考点在哪里（其实就是另外一种算法），我们是在不同算法中找到最优解，这样我们抛弃掉硬件环境等其他因素的影响，回归到算法自身层面上来进行分析执行效率与资源。这里引入 **大O复杂度表示法**

### 大O时间复杂度表示法

-   概念：表示代码的执行时间随数据规模n增长的变化趋势

    `T(n) = O(f(n))`   

-   表示法规则：当`f(n) = 2n²+n + 1`表示法会去掉常量、低阶、系数（不左右增长趋势）

    `f(n) = n²`

    `T(n) = O(n²)`   

### 时间复杂度分析

-   只关注循环次数最多的一段代码

    ```c++
    int sum(int n){
    	int sum1 = 0;  // 1个单位时间
    	int i = 1;  //  1个单位时间
    	for(; i<=n; ++i){  // n个单位时间
    		sum = sum + i;  // n个单位时间
    	}
    }
    ```

    `T(n)=O(n)`

-   嵌套循环相乘

-   最大量级

    ```c++
    int sum(int n){
        int sum1 = 0;  // 1个单位时间
    	int i = 1;  //  1个单位时间
    	for(; i<=n; ++i){  // n个单位时间
    		sum = sum + i;  // n个单位时间
    	}
        
    	int sum2 = 0;   // 1个单位时间
    	int a = 1;  //  1个单位时间
    	int b = 1;  // 1个单位时间
    	for(; a<=n; ++a){  // n个单位时间
    		b = 1  // n个单位时间
    		for(; b<=n; ++b){  // n*n个单位时间
    			sum = sum + a*b;  // n*n个单位时间
    		}
    	}
    }
    ```

    查看上面代码示例的嵌套循环，内部循环代码执行时间为外层循环n乘以内存循环n，即 n*n  → n²

    上面代码存在多个循环语句，只需要关注最大量级即可：`T(n)=O(n²)`

-   常见时间复杂度
    -   常量阶：`O(1)`
    -   对数阶：`O(logn)`
    -   线性阶：`O(n)`
    -   线性对数阶：`O(nlogn)`
    -   平方、立方、k次方阶：`O(n²)  O(n³)  O(n^k)`
    -   指数阶：`O(2^n)`
    -   乘阶：`O(n!)`

    ![](http://im.taolius.com/image/common-complexity.png) 

### 大O时间复杂度表示法

-   概念：指算法的存储空间与数据规模之间的增长关系
-   表示法规则与时间一样

### 空间复杂度分析

-   常量阶 分析过程中可忽略

    `int i=0`

-   与数据规模相关n

    `int[] a = new int[n]` 申请一个大小为n的数组，认为该代码空间复杂度为  `O(n)`

### 最好、最坏、平均、均摊时间复杂度

-   最好时间复杂度

    在理想情况下，执行一段代码的时间复杂度。

    在一个无序数组查找一个元素，我们通过简单循环遍历进行查找，并设定找到则跳出循环；

    如果遍历第一次就查找到了该元素，这就是在最理想情况下的查找，循环执行1次，那么该

    最好时间复杂度：`O(1)`

-   最坏时间复杂度

    在最坏情况下，执行一段代码的时间复杂度

    如果直到最后一个元素，才找到该元素。这就是最坏情况，循环执行n次

    最坏时间复杂度：`O(n)`

-   平均时间复杂度（更加严谨加权平均时间复杂度、期望时间复杂度）

    最好和最坏均为极限情况下，大多数情况并不是这样的，平均时间复杂度描述的是：平均情况下的时间复杂度（这里就需要引入概率论知识）

    假设需要查找的值在数组中的某一个位置，统计学知识可能告诉你可能是一个“正态分布”，概率会比较复杂，但这里我们假设出现杂数组中的任何位置的概率均一样 1/n

    出现在第1位，时间复杂度为 1

    出现在第2位，时间复杂度为 2

    ​			...

    出现在第n位，时间复杂度为n

    `f(n) = 1*1/n+2*1/n+ ......n*1/n = (1+2+....n)*1/n = n(1+n)/2*1/n =(n+n²)/2n`

    `T(n) = O(n)`

-   均摊时间复杂度
