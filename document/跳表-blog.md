### 跳表

### 说说链表的随机访问效率

-   链表的随机访问效率相对于数组是很低，每次要访问第k个值或者说访问一个等于给定值value的值均需要从头开始遍历，直到找到目标值，时间复杂度为 O(n)
-   跳表是基于链表的，它的出现提升了链表的随机访问效率(数据量较大时)，时间复杂度为O(logn)

### 跳表

-   基本结构

    ![](http://im.taolius.com/image/skip-list-struct.png)

    最底层为原始链表，跳表就是在原始链表的基础结构上增加 **索引层**

-   跳表的索引层

    -   索引层也类似于链表，只是在节点多加了一个 **down 指针** ，该指针指向下层节点

    -   索引层是怎么增加的呢？

        例如图中的索引层是以两个节点抽取一个索引节点；

        你可以三个节点抽取一个索引节点，以n个节点抽取一个索引节点也是可以的；但是这个n的取值会影响链表在查找值的效率，一般n的取值会根据链表的预计容量来进行取值；

-   跳表是怎样根据索引来查找目标值？

    假设我们要找的节点为图中的值等于 13 的节点（注意图中红色箭头）；

    我们先从最上层索引开始，根据value的值来判断，下一步的走向；当走到值为8的索引节点时，判断下一同级索引节点值比目标值大，则在值为8的索引节点进行**下跳**；

    同理到值为10的索引节点下跳，再到值为13的节点，找到目标值；

### 跳表的效率分析

-   查询效率分析

    ![](http://im.taolius.com/image/skip-list-search.png)

    上图为以 2节点抽取的 索引层 的跳表，以找到 值x的节点来分析查找效率；

    从图中可以看出，在每一级索引层均只需要一次节点值的比较以及一次下跳操作 m=2；

    当有n个数据时时，那下跳的次数是多少呢？由于我们是以 2个节点抽取一个索引节点，所以层数为  2^k=n，即k = $\log_2{n}$；

    所以在以 2个节点抽取的索引层的跳表在查找节点的时间复杂度为 O(T)= O(m*logn)，即为 O(logn)；

    以 3个节点抽取索引层？ 3^k=n，即k = $\log_3{n}$；而每一层需要2次比较操作和一次下跳操作 m=3

    以 4个节点抽取索引层？ 4^k=n，即k = $\log_4{n}$；而每一层需要3次比较操作和一次下跳操作 m=4

    由于省略常量阶，则跳表的查询 时间复杂度为  O(logn)

-   插入效率与删除效率

    插入节点，为了保证跳表的有序性，首先还是先找到节点位置，也就是前面说的查询；再进行数据的插入(单链表时间复杂度为O(1))，所以总的时间复杂度为 O(logn)；

    删除节点，与插入节点类似，均是先查找到目标节点位置，然后再进行删除(对于单链表需要获取前置节点，双向链表就不需要考虑了)，以及索引节点的删除，而删除索引节点的操作次数最多是logn，综合总的时间复杂度 O(logn)

### 跳表索引是不是很浪费内存

-   跳表相比链表来说增加了索引层的，而前面也解释了 索引层的抽取方式，我们来对比下不同的抽取方式在内存占用上的区别

    -   2个节点抽取

        索引层从底层索引到高层索引元素个数  `n/2, n/4, n/8, ..., 8, 4, 2`；

        根据等比数列求和：`n/2+n/4+....+2=n-2`， 空间复杂度为 O(n)

    -   3个节点抽取

        索引层从底层索引到高层索引元素个数  `n/3, n/9, n/27, ..., 27, 9, 3`；

        根据等比数列求和：`n/3+n/3+....+3=(n-3)/2`， 空间复杂度还是为 O(n)

        但是相比 2个节点来说，3个节点抽取还是省了大约一半的空间

-   实际应用中，由于存储的是数据，相比跳表的索引只存储关键值和指针来说，通常是小巫见大巫，根本是可以忽略的存在，所以可以不用考虑

### 跳表索引动态更新

-   跳表索引第一次创建之后就不变了吗？

    ![](http://im.taolius.com/image/skip-list-index.png)

    答案是否定的，它需要更新，不然当两节点之间插入的数据越来越多，而不更新索引，当查找值在该两节点之间时，在定位前一节点后，就需要进行遍历查找，当数据过大时，查找效率会降低；怎样防止出现这种情况呢？

-   索引动态更新

    ![](http://im.taolius.com/image/skip-list-index-update.png)

    跳表在插入数据时，通过 **随机函数** 来决定插入数据的索引节点应该添加到那几级索引层；

    例如 **随机函数** 生成 k 值，那么把该数据对应的索引节点加入到 1~k级这些索引层中；

    如图 k=2，则红色节点对应的索引节点会被加入到 1-2索引层

### 思考：为什么redis要用跳表来实现有序集合，而不是红黑树？

-   redis中的有序集合实现的操作接口

    -   插入一个数据
    -   删除一个数据
    -   查找一个数据
    -   按照区间查找数据
    -   迭代输出有序序列

    1.其中的 插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也能完成，时间复杂度与跳表一样。但是按照区间查找数据，红黑树效率没有跳表高；

    2.按照区间查找数据，跳表可以在O(logn)的时间复杂度内，查找到区间起点，然后往后遍历就可以了

    3.相对于红黑树，跳表数据结构代码实现起来更简单，减少出错





